/*
 * generated by Xtext 2.12.0
 */
package bergmann.masterarbeit.validation

import bergmann.masterarbeit.monitorDsl.Assertion
import bergmann.masterarbeit.monitorDsl.MonitorDslPackage
import bergmann.masterarbeit.monitorDsl.UserVariable
import org.eclipse.xtext.validation.Check
import bergmann.masterarbeit.monitorDsl.Expression
import bergmann.masterarbeit.monitorDsl.*
import bergmann.masterarbeit.utils.ExpressionTypeChecker
import static extension bergmann.masterarbeit.utils.ExpressionUtils.*
import static extension bergmann.masterarbeit.utils.ExpressionTypeChecker.*
import static extension bergmann.masterarbeit.utils.UnitUtils.*
import static extension bergmann.masterarbeit.utils.TimeUtils.*
import bergmann.masterarbeit.utils.ExpressionUtils
import bergmann.masterarbeit.monitorDsl.impl.AddImpl
import org.eclipse.xtext.EcoreUtil2
import bergmann.masterarbeit.mappingdsl.mappingDSL.Domain
import java.util.ArrayList
import java.util.HashMap
import org.eclipse.emf.ecore.util.EcoreUtil
import bergmann.masterarbeit.mappingdsl.mappingDSL.LiteralJava
import bergmann.masterarbeit.mappingdsl.mappingDSL.UnaryJava
import bergmann.masterarbeit.mappingdsl.mappingDSL.BinaryJava
import bergmann.masterarbeit.mappingdsl.mappingDSL.DomainValue
import bergmann.masterarbeit.mappingdsl.mappingDSL.DomainElement

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MonitorDslValidator extends AbstractMonitorDslValidator {
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital',
//					MonitorDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	@Check
	def checkExpressionType(UserVariable userVar){
		if(!userVar.expr.isValid){
			markSubexpressions(userVar.expr)
			error("Invalid User Variable. Can not resolve to a valid type", MonitorDslPackage.Literals.USER_VARIABLE__NAME)
		}
	}

	@Check
	def checkExpressionType(Assertion assertion){
		if(!assertion.expr.isBoolean){
			markSubexpressions(assertion.expr)
			error("Invalid Assertion. Can not resolve expression to boolean", MonitorDslPackage.Literals.ASSERTION__NAME)
		}
	}

	def markSubexpressions(Expression expr){
		if(!expr.isValid){
			var invalidSubexpressionFound = false
			for(Expression subExpr : expr.subexpressions){
				if(subExpr != null && !subExpr.isValid){
					markSubexpressions(subExpr)
					invalidSubexpressionFound = true
				}
			}
			if(!invalidSubexpressionFound){
				// Error must be in how this expression is used, not in some subexpression
				error("Subexpression can't be resolved to a valid type", expr.eContainer, expr.eContainingFeature, -1)
			}
		}
	}

	@Check
	def checkTimeIntervals(TimeIntervalSimple t){
		if(!(t.start.toMillisec <= t.end.toMillisec)){
			error("Interval start must be before end", t.eContainer, t.eContainingFeature, -1)
		}
	}
	
	@Check
	def checkTimeIntervals(LTL_Binary expr){
		if(expr.time == null){
			return
		}
		if (expr.time.isZero){
			warning("Given interval equals zero and can be removed.", MonitorDslPackage.Literals.LTL_BINARY__TIME)
			return
		}
		if(expr.time.containsNegative && expr.time.containsPositive){
			error("Mismatching signs for start and end are disallowed for '"+ expr.op +"'.", MonitorDslPackage.Literals.LTL_BINARY__TIME)
			return
		}
		switch expr.op {
			//LTL 
			case UNTIL,
			case WEAK_UNTIL,
			case RELEASE:{
				if(expr.time.containsNegative){
					error("Negative time interval for LTL operator.", MonitorDslPackage.Literals.LTL_BINARY__TIME)
				}
			}
			// PLTL
			case TRIGGER,
			case SINCE:{
				if(expr.time.containsPositive){
					error("Positive time interval for PLTL operator.", MonitorDslPackage.Literals.LTL_BINARY__TIME)
				}
			}
			// default
			default: throw new IllegalArgumentException("Unknown binary (P)LTL operator " + expr.op)
		}
	}
		@Check
	def checkTimeIntervals(LTL_Unary expr){
		if(expr.time == null){
			return
		}
		if (expr.time.isZero){
			warning("Given interval equals zero and can be removed.", MonitorDslPackage.Literals.LTL_UNARY__TIME)
			return 
		}
		if(expr.time.containsNegative && expr.time.containsPositive){
			error("Mismatching signs for start and end are disallowed for '"+ expr.op +"'.", MonitorDslPackage.Literals.LTL_UNARY__TIME)
			return
		}
		switch expr.op {
			//LTL 
			case NEXT,
			case FINALLY,
			case GLOBAL:{
				if(expr.time.containsNegative){
					error("Negative time interval for LTL operator.", MonitorDslPackage.Literals.LTL_UNARY__TIME)
				}
			} 
			// PLTL
			case YESTERDAY,
			case Z,
			case HISTORICALLY,
			case ONCE:{
				if(expr.time.containsPositive){
					error("Positive time interval for PLTL operator.", MonitorDslPackage.Literals.LTL_UNARY__TIME)
				}
			}
			// default
			default: throw new IllegalArgumentException("Unknown binary (P)LTL operator " + expr.op)
		}
	}

	@Check
	def unitMismatch(Add expr){
		var comp = expr.left.isUnitCompatible(expr.right)		 
		if (!comp){
			var lUnit = expr.left.unit
			var rUnit = expr.right.unit
			error("Incompatible units for operator " + expr.op + "\n\n[" + lUnit + "] " + expr.op + " [" + rUnit + "]", expr.eContainer, expr.eContainingFeature, -1)
		}		
	}
	@Check
	def unitMismatch(Rel expr){
		if(! (expr.left.isNumber && expr.right.isNumber))
			return
		var comp = expr.left.isUnitCompatible(expr.right)		 
		if (!comp){
			var lUnit = expr.left.unit
			var rUnit = expr.right.unit
			error("Incompatible units for operator " + expr.op + "\n\n[" + lUnit + "] " + expr.op + " [" + rUnit + "]", expr.eContainer, expr.eContainingFeature, -1)
		}		
	}
	
	@Check 
	def typeMismatch(IfThenElse expr){
		var tThen = expr.then.expressionType
		var tElse = expr.getElse.expressionType
		if(! tThen.equals(tElse)){
			error("Different, incompatible types for then and else\n then:[" + tThen + "] else:[" + tElse + "]", expr.eContainer, expr.eContainingFeature, -1) 
		}
	}
	
	@Check 
	def unitMismatch(IfThenElse expr){
		if(! (expr.then.isNumber && expr.getElse.isNumber))
			return
		var comp = expr.then.isUnitCompatible(expr.getElse)
		if(!comp){
			var lUnit = expr.then.unit
			var rUnit = expr.getElse.unit
			error("Different, incompatible units for then and else\n then:[" + lUnit + "] else:[" + rUnit + "]", expr.eContainer, expr.eContainingFeature, -1)
		}
	}
	
	@Check 
	def EqualsTypeWarning(Rel expr){
		if(expr.op.equals("==") || expr.op.equals("!=") )
			if(!expr.left.expressionType.equals(expr.right.expressionType))
				warning("Comparing two different datatypes: " + expr.left.expressionType + " and " + expr.right.expressionType + ". Resulting behaviour may be unpredictable",  expr.eContainer, expr.eContainingFeature, -1 )
	}
	
	@Check
	def IntervallAllowedCheck(LTL_Unary expr) {
		if(expr.time == null){
			return 
		}
		switch  expr.op {
			case NEXT,
			case YESTERDAY,
			case Z: error("Time constraints are currently not supported for given operator " + expr.op, MonitorDslPackage.Literals.LTL_UNARY__TIME)
		}
	}


	@Check
	def checkNamesAreUnique(Monitors monitors){
		var userVars = EcoreUtil2.eAllOfType(monitors, UserVariable)
		var assertions = EcoreUtil2.eAllOfType(monitors, Assertion)
		
		// Get names defined in imported domain files
		var domainNames = new HashMap<Import, ArrayList<String>>()
		for (Import i : monitors.imports){
			var d = EcoreUtil.getRootContainer(i.ref)
			var names = new ArrayList<String>()
			var elems = new ArrayList<DomainElement>()
			elems.addAll(EcoreUtil2.eAllOfType(d, LiteralJava))
			elems.addAll(EcoreUtil2.eAllOfType(d, UnaryJava))
			elems.addAll(EcoreUtil2.eAllOfType(d, BinaryJava))
			elems.addAll(EcoreUtil2.eAllOfType(d, DomainValue))
			for (j : elems) 
				names.add(j.name)
			domainNames.put(i, names)
		}
		
		for(entry : domainNames.entrySet){
			var domain = entry.key
			var elems = entry.value
			// Compare other domains
			for (e : elems) {
				for(entry2 : domainNames.entrySet){
					var domain2 = entry2.key
						if(domain != domain2){
							var elems2 = entry2.value
							if(elems2.contains(e)){
								error("Duplicate Identifier: " + e + ". Also used in domain " + domain2.ref.name, domain,MonitorDslPackage.Literals.IMPORT__REF )								
							}
						}
					}

				// Compare userVars
				for (uVar : userVars) {
					if(uVar.name.equals(e)){
						error("Duplicate Identifier: " + e + ". Also used in domain " + domain.ref.name, uVar,MonitorDslPackage.Literals.USER_VARIABLE__NAME )
					}
				}
				// Compare assertions
				for (ass  : assertions) {
					if(ass.name.equals(e)){
						error("Duplicate Identifier: " + e + ". Also used in domain " + domain.ref.name, ass,MonitorDslPackage.Literals.ASSERTION__NAME )
					}
				}
			}
		}
	}


}

