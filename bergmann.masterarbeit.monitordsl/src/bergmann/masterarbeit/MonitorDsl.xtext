grammar bergmann.masterarbeit.MonitorDsl with org.eclipse.xtext.common.Terminals

generate monitorDsl "http://www.masterarbeit.bergmann/MonitorDsl"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore 
import "http://www.masterarbeit.bergmann/mappingdsl/MappingDSL" as mapping


Monitors:
	{Monitors} package=PackageDeclaration (imports+=Import)* (assertions+=Assertion | uservars+=UserVariable)*
;

PackageDeclaration:
	{PackageDeclaration} "monitor" name=ID
;

Import:
	{Import} 'import' "domain" ref=[mapping::PackageDeclaration] ("as" name=ID)?
;

UserVariable:
	{UserVariable} "def" "var" name=ID ":=" expr=Expression	
;

Assertion: 
	{Assertion} "def" "assertion" name=ID ':=' expr=Expression
;

Expression:
	TimeOffsetExpr
;

TimeOffsetExpr returns Expression:
	ImplicationExpr ({TimeOffset.expr=current} offset=ExpressionTimeOffset)?
;

ExpressionTimeOffset:
	{StateOffset}  "[" "at"? op=("+"|"-") value=INT ("state"|"states")"]"
	| {TimeOffset} "[" "at"? op=("+"|"-") value=INT unit=TIME_UNIT"]"
;

ImplicationExpr returns Expression:
	OrExpr ({Implication.left=current} op=('->'|'implies') right=OrExpr)*
;

OrExpr returns Expression:
	AndExpr ({Or.left=current} op=('or'|'|'|'||') right=AndExpr)*
;

AndExpr returns Expression:
	LTLInfixExpression ({And.left=current} op=('and'|'&'|'&&') right=LTLInfixExpression)*
;

LTLInfixExpression returns Expression:
	LTLUnaryExpression ({LTL_Binary.left=current} op=BINARY_LTL_OPERATOR (time=TimeInterval)? right=LTLUnaryExpression)*
;

LTLUnaryExpression returns Expression:
	RelExpr | {LTL_Unary} op=UNARY_LTL_OPERATOR (time=TimeInterval)? expr=RelExpr
;

RelExpr returns Expression:
	AddExpr ({Rel.left=current} op=('<'|'<='|'=='|'='|'!='|'>'|'>=') right=AddExpr)*
;

AddExpr returns Expression:
	MultExpr ({Add.left=current} op=('+'|'-') right=MultExpr)*
;

MultExpr returns Expression:
	UnExpr ({Mult.left=current} op=('*'|'/') right=UnExpr)*
;

UnExpr returns Expression: 
	{Negation} op=('!'|"-"|'not') expr=MappingBinary 
	| MappingBinary
;

MappingBinary returns Expression:
	MappingUnary ({MappingBinary.left=current} ref=[ecore::EObject]  right=LTLUnaryExpression)*
;

MappingUnary returns Expression:
	AtomExpr | {MappingUnary} "<"  ref=[ecore::EObject]  expr=AtomExpr ">"
;

AtomExpr returns Expression: 
	{Subexpression} '(' expr=Expression ')'
	// Literals
	| {IntLiteral} value=INT unit=Unit?
	| {FloatLiteral} value=FLOAT unit=Unit?
	| {BoolLiteral} value=("true" | "false")	
	| {StringLiteral} value=STRING
	// User Variable
	| {AggregateExpression} op=AGGREGATE_OPERATOR time=TimeInterval "("expr=Expression")"
	// MappingVariable
	| {CrossReference} ref=[ecore::EObject] 
	| {IfThenElse} "if" condition=Expression "then" then=Expression "else" else=Expression
;


TimeInterval:
	{TimeIntervalSimple} left=('['|'(') start=TimeAtom ',' end=TimeAtom right=(']'|')')
	| {TimeIntervalSingleton} '[' value=TimeAtom ']'
	| {TimeIntervalInequalityNotation} '[' op=('<'|'<='|'>'|'>=') value=TimeAtom ']'
	
;

TimeAtom:
	{TimeLiteral} neg?="-"? value=INT unit=TIME_UNIT
	| {InfinityTimeAtom} neg?="-"? value="infinity"
;

enum AGGREGATE_OPERATOR:
	AVG = "avg" | AVG = "average"
	| MIN = "min" | MIN = "minimum"
	| MAX = "max" | MAX = "maximum"
;

enum UNARY_LTL_OPERATOR:
	NEXT =  'next' | NEXT = 'X' 
	| FINALLY = 'finally' | FINALLY = 'F' 
	| GLOBAL = 'globally' | GLOBAL = 'G' 
	| YESTERDAY = 'yesterday' | YESTERDAY = 'Y' 
	| ONCE = 'once' | ONCE = 'O'  
	| HISTORICALLY = 'historically' | HISTORICALLY =  'H'
	| Z = "Z"
;

enum BINARY_LTL_OPERATOR:
	  UNTIL = 'until' | UNTIL = 'U' 
	| RELEASE = 'release' | RELEASE = 'R' 
	| WEAK_UNTIL = 'weak_until' | WEAK_UNTIL = 'W' 
	| SINCE = 'since' | SINCE = 'S' 
	| TRIGGER = 'trigger' | TRIGGER = 'T'
;


Unit:
 	UnitDivision
;

UnitDivision returns Unit:
	UnitMultiplication ({UnitDiv.left=current} "/" right=UnitMultiplication)*
;

UnitMultiplication returns Unit:
	UnitExponent ({UnitMult.left=current} "*" right=UnitExponent)*
;

UnitExponent returns Unit:
	UnitAtom ({UnitExponent.value=current} '^' negative?='-'? exponent=INT)?
;

UnitAtom returns Unit:
	{UnitBraces} '(' unit=Unit ')'
	| {UnitLiteralAtom} unit=(LengthUnitLiteral  | TimeUnitLiteral)
;


LengthUnitLiteral returns UnitLiteral:
	{LengthUnitLiteral} unit=LENGTH_UNIT
;
TimeUnitLiteral returns UnitLiteral:
	{TimeUnitLiteral} unit=TIME_UNIT
;

terminal TIME_UNIT:
	"ms" | "s"| "min" | "h"
;

terminal LENGTH_UNIT:
	'mm' | 'cm' | 'm' | 'km'
;

terminal FLOAT returns ecore::EFloat: INT '.' INT;
FQN: ID ("." ID)*;

	