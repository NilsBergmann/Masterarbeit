grammar bergmann.masterarbeit.MonitorDsl with org.eclipse.xtext.common.Terminals

generate monitorDsl "http://www.masterarbeit.bergmann/MonitorDsl"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore 
import "http://www.masterarbeit.bergmann/mappingdsl/MappingDSL" as mapping


Prog:
	(imports+=Import)*
	ops+=(Assertion | UserVariable)*
;



Import:
	'import' path=STRING 'as' name=ID
;

UserVariable:
	"def" "var" name=ID ":=" expr=Expression	
;

Assertion: 
	"def" "assertion" name=ID ':=' expr=Expression
;

Expression:
	ImplicationExpr
;

ImplicationExpr returns Expression:
	OrExpr ({Impl.left=current} op=('->'|'<->'|'implies'|'iff') right=AndExpr)*
;

OrExpr returns Expression:
	AndExpr ({Or.left=current} op=('or'|'|'|'||') right=AndExpr)*
;

AndExpr returns Expression:
	LTLInfixExpression ({And.left=current} op=('and'|'&'|'&&') right=LTLInfixExpression)*
;

LTLInfixExpression returns Expression:
	LTLUnaryExpression ({LTL_Binary.left=current} op=BINARY_LTL_OPERATOR right=LTLUnaryExpression)*
;

LTLUnaryExpression returns Expression:
	RelExpr | {LTL_Unary} op=UNARY_LTL_OPERATOR expr=RelExpr
;

RelExpr returns Expression:
	AddExpr ({Rel.left=current} op=('<'|'<='|'=='|'='|'!='|'>'|'>=') right=AddExpr)*
;

AddExpr returns Expression:
	MultExpr ({Add.left=current} op=('+'|'-') right=MultExpr)*
;

MultExpr returns Expression:
	UnExpr ({Mult.left=current} op=('*'|'/') right=UnExpr)*
;

UnExpr returns Expression: 
	{Negation} op=('!'|"-"|'not') exprAtom=AtomExpr | AtomExpr
;

AtomExpr returns Expression: 
	{Subexpression} '(' expr=Expression ')'
	// Literals
	| {IntLiteral} value=INT
	| {FloatLiteral} value=FLOAT
	| {BoolLiteral} value=("true" | "false")	
	// User Variable
	| {UserVarAtom} ref=[UserVariable]
	// MappingVariable
	| {MappingTest} importScope=[Import] '.' ref=[mapping::Definition]
;

terminal UNARY_LTL_OPERATOR:
	  'next' | 'X' 
	| 'finally' | 'F' 
	| 'globally' | 'G' 
	| 'previous' | 'Y' 
	| 'once' | 'O'  
	| 'historically' | 'H'
;

terminal BINARY_LTL_OPERATOR:
	  'until' | 'U' 
	| 'release' | 'R' 
	| 'weak_until' | 'W' 
	| 'strong_release' | 'M' 
	| 'since' | 'S' 
	| 'weak_since' | 'B'
;

terminal FLOAT returns ecore::EFloat: INT '.' INT;

	