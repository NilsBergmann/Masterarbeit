grammar bergmann.masterarbeit.MonitorDsl with org.eclipse.xtext.common.Terminals

generate monitorDsl "http://www.masterarbeit.bergmann/MonitorDsl"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore 
import "http://www.masterarbeit.bergmann/mappingdsl/MappingDSL" as mapping


Prog:
	(imports+=Import)*
	ops+=(Assertion | UserVariable)*
;

Import:
	'import' path=STRING 'as' name=ID
;

UserVariable:
	"def" "var" name=ID ":=" expr=Expression	
;

Assertion: 
	"def" "assertion" name=ID ':=' expr=Expression
;

Expression:
	ImplicationExpr
;

ImplicationExpr returns Expression:
	OrExpr ({Impl.left=current} op=('->'|'<->'|'implies'|'iff') right=AndExpr)*
;

OrExpr returns Expression:
	AndExpr ({Or.left=current} op=('or'|'|'|'||') right=AndExpr)*
;

AndExpr returns Expression:
	LTLInfixExpression ({And.left=current} op=('and'|'&'|'&&') right=LTLInfixExpression)*
;

LTLInfixExpression returns Expression:
	LTLUnaryExpression ({LTL_Binary.left=current} op=BINARY_LTL_OPERATOR (constraint=TimeIntervalConstraint)? right=LTLUnaryExpression)*
;

LTLUnaryExpression returns Expression:
	RelExpr | {LTL_Unary} op=UNARY_LTL_OPERATOR (constraint=TimeIntervalConstraint)? expr=RelExpr
;

RelExpr returns Expression:
	AddExpr ({Rel.left=current} op=('<'|'<='|'=='|'='|'!='|'>'|'>=') right=AddExpr)*
;

AddExpr returns Expression:
	MultExpr ({Add.left=current} op=('+'|'-') right=MultExpr)*
;

MultExpr returns Expression:
	UnExpr ({Mult.left=current} op=('*'|'/') right=UnExpr)*
;

UnExpr returns Expression: 
	{Negation} op=('!'|"-"|'not') exprAtom=AtomExpr 
	| AtomExpr
;

AtomExpr returns Expression: 
	{Subexpression} '(' expr=Expression ')'
	// Literals
	| {IntLiteral} value=INT unit=Unit?
	| {FloatLiteral} value=FLOAT unit=Unit?
	| {BoolLiteral} value=("true" | "false")	
	// User Variable
	| {UserVarAtom} ref=[UserVariable]
	// MappingVariable
	| {MappingTest} importScope=[Import] '.' ref=[mapping::Definition] 
;

TimeIntervalConstraint:
	{TimeIntervalSimple} left=('['|'(') start=TimeAtom ',' end=TimeAtom right=(']'|')')
	| {TimeIntervalSingleton} '[' value=TimeAtom ']'
	| {TimeIntervalInequalityNotation} '[' op=('<'|'<='|'>'|'>=') value=TimeAtom ']'
	
;

TimeAtom:
	{TimeLiteral} value=INT unit=TIME_UNIT
	| {InfinityTimeAtom} "infinity"
;



terminal UNARY_LTL_OPERATOR:
	  'next' | 'X' 
	| 'finally' | 'F' 
	| 'globally' | 'G' 
	| 'previous' | 'Y' 
	| 'once' | 'O'  
	| 'historically' | 'H'
;

terminal BINARY_LTL_OPERATOR:
	  'until' | 'U' 
	| 'release' | 'R' 
	| 'weak_until' | 'W' 
	| 'strong_release' | 'M' 
	| 'since' | 'S' 
	| 'weak_since' | 'B'
;


Unit:
 	UnitDivision
;

UnitDivision returns Unit:
	UnitMultiplication ({UnitDiv.left=current} "/" right=UnitMultiplication)*
;

UnitMultiplication returns Unit:
	UnitExponent ({UnitMult.left=current} "*" right=UnitExponent)*
;

UnitExponent returns Unit:
	{UnitExponent} (value=UnitAtom '^' exponent=INT)
	| UnitAtom
;

UnitAtom returns Unit:
	{UnitBraces} '(' unit=Unit ')'
	| {UnitLiteral} value=UnitLiteral
;

UnitLiteral:
	LENGTH_UNIT  | TIME_UNIT
;

terminal LENGTH_UNIT:
	"mm" | 'cm' | 'm' | 'km'
;
terminal TIME_UNIT:
	"ms" | "s" 	| "m" | "h" 
;

terminal FLOAT returns ecore::EFloat: INT '.' INT;

	