grammar bergmann.masterarbeit.mappingdsl.MappingDSL with org.eclipse.xtext.xbase.Xtype
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes

generate mappingDSL "http://www.masterarbeit.bergmann/mappingdsl/MappingDSL"

Domain:
	package=PackageDeclaration
	elems+=DomainElement*
;

PackageDeclaration:
	{PackageDeclaration} "domain" name=ID
;

DomainElement:
	JavaDataType | DomainValue | CustomJava
;

JavaDataType:
	{JavaDataType}
	"datatype:" "{"
	(
		("name:" name=ID ) &
		("javaClass:" ref=JavaClassReference)
	)
"}"
;

CustomJava:
	LiteralJava | UnaryJava | BinaryJava
;

JavaClassReference:
	{JavaClassReference} javaType=[jvmTypes::JvmDeclaredType|QualifiedName]
;

LiteralJava returns CustomJava:
	{LiteralJava}
	"Java" "{"
	(
		("name:" name=ID) &
		("type:" type=Type) &
		("unit:" unit=Unit)? &
		("description:" description=STRING)? &
		("javaClass:" ref=JavaClassReference)
	)
	"}"
;

UnaryJava returns CustomJava:
	{UnaryJava}
	"Java" "{"
	(
		("name:" name=ID) &
		("type:" type1=Type "->" type2=Type) &
		("unit:" unit=Unit)? &
		("description:" description=STRING)? &
		("javaClass:" ref=JavaClassReference)
	)
	"}"
;

BinaryJava returns CustomJava:
	{BinaryJava}
	"Java" "{"
	(
		("name:" name=ID) &
		("type:" type1=Type "->" type2=Type "->" type3=Type) &
		("unit:" unit=Unit)? &
		("description:" description=STRING)? &
		("javaClass:" ref=JavaClassReference)
	)
	"}"
;
DomainValue:
	{DomainValue}
	"databaseValue:" "{"
	(
		("name:" name=ID) &
		("type:" type=BASE_VALUETYPE) &
		("unit:" unit=Unit)? &
		("description:" description=STRING)? &
		("column:" column=STRING) 
	)
	"}"
;

Type:
	{JavaType} type=[JavaDataType] | {BaseType} type=BASE_VALUETYPE
;
enum BASE_VALUETYPE:
	NUMBER = "number" | STRING = "string" | BOOLEAN = "boolean"
;

Unit:
 	UnitDivision
;

UnitDivision returns Unit:
	UnitMultiplication ({UnitDiv.left=current} "/" right=UnitMultiplication)*
;

UnitMultiplication returns Unit:
	UnitExponent ({UnitMult.left=current} "*" right=UnitExponent)*
;

UnitExponent returns Unit:
	UnitAtom ({UnitExponent.value=current} '^' negative?='-'? exponent=INT)?
;

UnitAtom returns Unit:
	{UnitBraces} '(' unit=Unit ')'
	| {UnitLiteralAtom} unit=(LengthUnitLiteral  | TimeUnitLiteral)
;


LengthUnitLiteral returns UnitLiteral:
	{LengthUnitLiteral} unit=LENGTH_UNIT
;
TimeUnitLiteral returns UnitLiteral:
	{TimeUnitLiteral} unit=TIME_UNIT
;

terminal TIME_UNIT:
	"ms" | "s"| "min" | "h"
;

terminal LENGTH_UNIT:
	'mm' | 'cm' | 'm' | 'km'
;

terminal INT returns ecore::EInt: ('0'..'9')+;
FQN: ID ("." ID)*;