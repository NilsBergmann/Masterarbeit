/*
 * generated by Xtext 2.12.0
 */
package bergmann.masterarbeit.mappingdsl.validation

import bergmann.masterarbeit.mappingdsl.mappingDSL.BinaryJava
import bergmann.masterarbeit.mappingdsl.mappingDSL.CustomJava
import bergmann.masterarbeit.mappingdsl.mappingDSL.LiteralJava
import bergmann.masterarbeit.mappingdsl.mappingDSL.UnaryJava
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference
import org.eclipse.xtext.validation.Check

import static extension bergmann.masterarbeit.mappingdsl.utils.MappingUtils.*
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.xbase.jvmmodel.JvmTypeReferenceBuilder.Factory
import org.eclipse.xtext.common.types.JvmTypeReference
import java.util.List
import org.eclipse.xtext.common.types.JvmOperation
import org.eclipse.xtext.common.types.JvmMember
import org.eclipse.xtext.common.types.JvmType
import bergmann.masterarbeit.mappingdsl.mappingDSL.MappingDSLPackage
import bergmann.masterarbeit.mappingdsl.mappingDSL.DomainValue
import bergmann.masterarbeit.mappingdsl.mappingDSL.BASE_VALUETYPE
import bergmann.masterarbeit.mappingdsl.mappingDSL.Type
import bergmann.masterarbeit.mappingdsl.mappingDSL.BaseType

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MappingDSLValidator extends AbstractMappingDSLValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MappingDSLPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	@Check 
	def checkTypeMatching(CustomJava cj){
		var expectedInterface = cj.expectedQualifiedExpressionName			
		var referenced = cj.ref.javaType
		var EList<JvmTypeReference> superTypes = referenced.superTypes
		var found = false
		for (JvmTypeReference t : superTypes){
			if(t.qualifiedName.equals(expectedInterface))
				found = true
		}
		if (!found)
			error("Referenced class doesn't implement the expected interface:\n\n" + expectedInterface,cj.ref, MappingDSLPackage.Literals.JAVA_CLASS_REFERENCE__JAVA_TYPE, -1)
		return
	}
	
	@Check
	def checkUnit(DomainValue dv){
		if(dv.type != BASE_VALUETYPE.NUMBER && dv.unit != null)
			error("Values of type " + dv.type + " can not have a unit", MappingDSLPackage.Literals.DOMAIN_VALUE__UNIT)
	}
	
	@Check
	def checkUnit(CustomJava jv){
		if(jv.unit==null)
			return
		else{
			var Type relevantType
			switch jv {
				LiteralJava: relevantType = jv.type
				UnaryJava: relevantType = jv.type2
				BinaryJava: relevantType = jv.type3
				default: throw new IllegalArgumentException("Unknown CustomJava element: " +jv)
			}
			if (!(relevantType instanceof BaseType) || (relevantType as BaseType).type != BASE_VALUETYPE.NUMBER)
				error("Type " + relevantType + " can not have a unit", MappingDSLPackage.Literals.CUSTOM_JAVA__UNIT)
			else 
				info("There is no verification of the actual return unit. Make sure the actual return type is comaptible", MappingDSLPackage.Literals.CUSTOM_JAVA__UNIT)
		}
	}
}
