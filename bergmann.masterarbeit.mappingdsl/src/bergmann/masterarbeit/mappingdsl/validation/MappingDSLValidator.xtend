/*
 * generated by Xtext 2.12.0
 */
package bergmann.masterarbeit.mappingdsl.validation

import bergmann.masterarbeit.mappingdsl.mappingDSL.BinaryJava
import bergmann.masterarbeit.mappingdsl.mappingDSL.CustomJava
import bergmann.masterarbeit.mappingdsl.mappingDSL.LiteralJava
import bergmann.masterarbeit.mappingdsl.mappingDSL.UnaryJava
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference
import org.eclipse.xtext.validation.Check

import static extension bergmann.masterarbeit.mappingdsl.utils.MappingUtils.*
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.xbase.jvmmodel.JvmTypeReferenceBuilder.Factory
import org.eclipse.xtext.common.types.JvmTypeReference
import java.util.List
import org.eclipse.xtext.common.types.JvmOperation
import org.eclipse.xtext.common.types.JvmMember
import org.eclipse.xtext.common.types.JvmType
import bergmann.masterarbeit.mappingdsl.mappingDSL.MappingDSLPackage

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MappingDSLValidator extends AbstractMappingDSLValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MappingDSLPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	@Check 
	def checkTypeMatching(CustomJava cj){
		var expectedInterface = cj.expectedQualifiedExpressionName			
		var referenced = cj.ref.javaType
		var EList<JvmTypeReference> superTypes = referenced.superTypes
		var found = false
		for (JvmTypeReference t : superTypes){
			if(t.qualifiedName.equals(expectedInterface))
				found = true
		}
		if (!found)
			error("Referenced class doesn't implement the expected interface (" + expectedInterface + ")",cj.ref, MappingDSLPackage.Literals.JAVA_CLASS_REFERENCE__JAVA_TYPE, -1)
		return
	}
	
}
